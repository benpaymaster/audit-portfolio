# Reentrancy Vulnerability

## 1. Description
Reentrancy occurs when a contract makes an external call to another contract **before updating its own state**, allowing the callee to re-enter the function and execute it repeatedly.

## 2. Why it Happens
- Logic updates state after transferring funds
- Unprotected external calls (`call()`, `transfer()`, `send()`)
- Missing mutex or `nonReentrant` modifier

## 3. Exploit Scenario
A malicious contract:
- Calls the vulnerable function
- Receives an external call
- Re-enters the function to drain funds before state changes

## 4. How to Detect
During an audit, look for:
- External calls before state changes
- Calls to unknown addresses
- Lack of `nonReentrant` guard

## 5. Remediation
- Apply Checks-Effects-Interactions
- Add `ReentrancyGuard`
- Avoid external calls where unnecessary

## 6. Secure Pattern
```solidity
function withdraw() external nonReentrant {
    uint amount = balances[msg.sender];
    balances[msg.sender] = 0;
    payable(msg.sender).call{value: amount}("");
}
